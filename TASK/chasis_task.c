#include "can1.h"
#include "can2.h"
#include "uart1.h"
#include "uart3.h"
#include "task.h"
#include "delay.h"
#include "Judge_System.h"
#include "gpio.h"
//#include "pstwo.h"
#include "pwm.h"
#include "includes.h"
int angle_3=150;
int angle_2=90;
int angle_11=135;

int16_t output_202=0;
int16_t output_203=0;



int16_t target_velo_202=0;
int16_t target_velo_203=0;
int16_t target_velo_204=0;

int16_t Adc_Volt,limit_shift,cap_error=1;

int16_t error1=0,error2=0,error3=0,error4=0;
float anger_Vw[2];
u8 flag_Vw=0,flag_chasis_mode_shift=0,count_chasis_mode_shift=1;
uint32_t sum_chasis_output;
u8 flag_chasis_turnback=0,flag_ahead=0,flag_capacitance_switch=1;
int16_t last_chasis_mode;
u8 flag_chasis_spin_limit_off=1,storage_swtich;
u8 flag_storage_on=0;

static uint16_t ctlValue = 10 * 100;

enum mode
{
	spin_mode,
	follow_mode,
	uniaxial_mode,
	lock_mode        //锁定模式 打符
}chasis_mode=follow_mode;



void TX2_USART3_Init(void);
void TX2_Transmit_Start(void);
void Chasis_task(void *p_arg)
{
		OS_ERR err;
		p_arg = p_arg; 
	
		while(1)
	{  
//    Chasis_ESC_Send(500,0,500,0);
//		clock_900++;
		//id1 正退 id2正退 id3正退
//		if(ENABLE_yes==1)
//		{
//			setMotorTargetSpeed(0x01,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x01,0x06,0x01,0x0A,0x00,0x00,0x00,0x00);
//		  setMotorTargetPosition_2(0x02,0x06,0x01,0x0A,0xff,0x9b,0xff,0xff);
		
				uint8_t bytes[4];  // 用于存储4个字节的数组

				// 分解 int32_t 变量为4个字节
				bytes[0] = (snake_motor_position[2] >> 24) & 0xFF;  // 最高有效字节 (MSB)
				bytes[1] = (snake_motor_position[2] >> 16) & 0xFF;  // 次高有效字节
				bytes[2] = (snake_motor_position[2] >> 8) & 0xFF;   // 次低有效字节
				bytes[3] = snake_motor_position[2] & 0xFF;          // 最低有效字节 (LSB)
				setMotorTargetPosition(0x03,0x06,0x01,0x0A,bytes[0],bytes[1],bytes[2],bytes[3]); //设定目标位置值，32位有符号数；
//			delay_us(400000);
//			setMotorTargetPosition(0x03,0x06,0x01,0x0A,0x00,0x01,0x00,0x00); //设定目标位置值，32位有符号数；

//		  setMotorTargetPosition(0x04,0x06,0x01,0x0A,0xff,0x0ff,0x80,0x00);
//		  setMotorTargetPosition(0x05,0x06,0x01,0x0A,0x00,0x02,0xf0,0x00);
//		  setMotorTargetPosition(0x06,0x06,0x01,0x0A,0x00,0x00,0x00,0x00);
//		  setMotorTargetPosition(0x07,0x06,0x01,0x0A,0x00,0x02,0x80,0x00);
//		  setMotorTargetPosition(0x08,0x06,0x01,0x0A,0x00,0x00,0x00,0x00);
//  			setMotorTargetPosition(0x09,0x06,0x01,0x0A,0x00,0x00,0x80,0x00);
//  		  setMotorTargetPosition(0x0a,0x06,0x01,0x0A,0x00,0x00,0x80,0x00);
//		    setMotorTargetPosition(0x0b,0x06,0x01,0x0A,0xff,0xff,0x80,0x00);
//		    setMotorTargetPosition(0x0c,0x06,0x01,0x0A,0xff,0xff,0x80,0x00);
//			delay_us(400000);
//			setMotorTargetSpeed(0x02,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x02,0x06,0x01,0x0A,0x00,0x00,0x80,0x00);
//			delay_us(400000);
//			setMotorTargetSpeed(0x03,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x03,0x06,0x01,0x0A,0xff,0xff,0x88,0x00);
//			delay_us(500000);
//			setMotorTargetSpeed(0x04,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x04,0x06,0x01,0x0A,0xFF,0xFF,0x88,0x00);
//			delay_us(500000);
//			setMotorTargetSpeed(0x05,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x05,0x06,0x01,0x0A,0x00,0x0a,0x00,0x00);
//			delay_us(400000);
//			setMotorTargetSpeed(0x06,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x06,0x06,0x01,0x0A,0x00,0x0a,0x00,0x00);
//			delay_us(400000);
//			setMotorTargetSpeed(0x07,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x07,0x06,0x01,0x0A,0x00,0x0a,0x00,0x00);
//			delay_us(400000);
//			setMotorTargetSpeed(0x08,0x06,0x01,0x09,0x00,0x00,0x2A,0xAA);
//			setMotorTargetPosition(0x08 ,0x06,0x01,0x0A,0x00,0x0a,0x00,0x00);
//			delay_us(400000);
			

//			clock_900=316;
//		}
//		readMotorCurrentValue(0x03,0x02,0x03,0x05);
		OSTimeDly(8,OS_OPT_TIME_PERIODIC,&err); //延时8ms	
	}
	
}

